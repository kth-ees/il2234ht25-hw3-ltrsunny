# Question 1


## 1. Mealy FSM
Because the output *detected* is based on both of the current state and the input *input_sequence*.


## 2. State diagram

| State | description               |
|--------|------------------------|
| S0     |  0 consecutive ones was detected |  
| S1     | 1 consecutive ones was detected               | 
| S2     | 2 consecutive ones was detected               | 
| S3     | 3 consecutive ones was detected               | 
| S4     | 4 consecutive ones was detected               | 
| S5     | 5 or more consecutive ones was detected, detected=1| 

### Diagram
```
reset(rst_n=0)→ S0
S0:
  input_sequence 0 → S0(detected 0);
  input_sequence 1 → S1(detected 0)
S1:
  input_sequence 0 → S0(detected 0);
  input_sequence 1 → S2(detected 0)
S2:
  input_sequence 0 → S0(detected 0);
  input_sequence 1 → S3(detected 0)
S3:
  input_sequence 0 → S0(detected 0);
  input_sequence 1 → S4(detected 0)
S4:
  input_sequence 0 → S0(detected 0);
  input_sequence 1 → S5(detected 1)
S5:
  input_sequence 0 → S0(detected 0);
  input_sequence 1 → S5(detected 1)
```


## 3. Derive the next state logic using D flops
采用3个D触发器（`Q2, Q1, Q0`）存储当前状态，需推导**次态（Q2_next, Q1_next, Q0_next）** 和**输出（detected）** 的布尔表达式。


### 3.1 输出逻辑（detected）
由状态转移规则，仅两种情况`detected=1`：  
- 状态S4（100）且输入=1；  
- 状态S5（101）且输入=1。  

合并简化：  
`detected = (Q2·~Q1·~Q0·in) ∨ (Q2·~Q1·Q0·in) = Q2·~Q1·in`  
（`in`即`input_sequence`，`·`表示与，`∨`表示或，`~`表示非）


### 3.2 次态逻辑（Q2_next, Q1_next, Q0_next）
次态是“当前状态+输入”的函数，复位时（`rst_n=0`）次态全为0，正常工作（`rst_n=1`）时推导如下：

#### （1）Q2_next（最高位次态）
| 当前状态（Q2Q1Q0） | 输入=0 | 输入=1 | Q2_next |
|--------------------|--------|--------|---------|
| 000（S0）          | 0      | 0      | 0       |
| 001（S1）          | 0      | 0      | 0       |
| 010（S2）          | 0      | 0      | 0       |
| 011（S3）          | 0      | 1      | 1（S3→S4） |
| 100（S4）          | 0      | 1      | 1（S4→S5） |
| 101（S5）          | 0      | 1      | 1（S5→S5） |

布尔表达式：  
`Q2_next = (~Q2·Q1·Q0·in) ∨ (Q2·~Q1·in)`


#### （2）Q1_next（中间位次态）
| 当前状态（Q2Q1Q0） | 输入=0 | 输入=1 | Q1_next |
|--------------------|--------|--------|---------|
| 000（S0）          | 0      | 0      | 0       |
| 001（S1）          | 0      | 1      | 1（S1→S2） |
| 010（S2）          | 0      | 1      | 1（S2→S3） |
| 011（S3）          | 0      | 0      | 0（S3→S4） |
| 100（S4）          | 0      | 0      | 0（S4→S5） |
| 101（S5）          | 0      | 0      | 0（S5→S5） |

布尔表达式：  
`Q1_next = (~Q2·~Q1·Q0·in) ∨ (~Q2·Q1·~Q0·in)`


#### （3）Q0_next（最低位次态）
| 当前状态（Q2Q1Q0） | 输入=0 | 输入=1 | Q0_next |
|--------------------|--------|--------|---------|
| 000（S0）          | 0      | 1      | 1（S0→S1） |
| 001（S1）          | 0      | 0      | 0（S1→S2） |
| 010（S2）          | 0      | 1      | 1（S2→S3） |
| 011（S3）          | 0      | 0      | 0（S3→S4） |
| 100（S4）          | 0      | 1      | 1（S4→S5） |
| 101（S5）          | 0      | 1      | 1（S5→S5） |

布尔表达式：  
`Q0_next = (~Q2·~Q0·in) ∨ (Q2·~Q1·in)`


## 4. 结构化SystemVerilog建模（门级）
结构化建模需用**门级原语**（`and/or/not/dff`）实现次态逻辑和D触发器，假设D触发器为**异步高有效复位**。

```systemverilog
module sequence_detector_structural(
    input  logic clk,          // 时钟
    input  logic rst_n,        // 异步低有效复位
    input  logic input_sequence, // 输入序列
    output logic detected      // 检测输出
);

// 内部信号声明：D触发器输出、次态、反相信号
logic Q2, Q1, Q0;       // 当前状态（D触发器输出）
logic Q2_next, Q1_next, Q0_next; // 次态
logic not_rst_n, not_Q2, not_Q1, not_Q0, not_in; // 反相信号

// 1. 生成反相信号（供门级逻辑使用）
not u1(not_rst_n,   rst_n);        // 复位反相（适配DFF高有效复位）
not u2(not_Q2,      Q2);           // Q2反相
not u3(not_Q1,      Q1);           // Q1反相
not u4(not_Q0,      Q0);           // Q0反相
not u5(not_in,      input_sequence); // 输入反相

// 2. 实现Q2_next逻辑：Q2_next = (~Q2·Q1·Q0·in) ∨ (Q2·~Q1·in)
and u6(term1a, not_Q2, Q1);        // ~Q2 & Q1
and u7(term1b, Q0, input_sequence); // Q0 & in
and u8(term1,  term1a, term1b);    // ~Q2&Q1&Q0&in（第一项）
and u9(term2a, Q2, not_Q1);        // Q2 & ~Q1
and u10(term2, term2a, input_sequence); // Q2&~Q1&in（第二项）
or  u11(Q2_next, term1, term2);    // 两项或操作得到Q2_next

// 3. 实现Q1_next逻辑：Q1_next = (~Q2·~Q1·Q0·in) ∨ (~Q2·Q1·~Q0·in)
and u12(term3a, not_Q2, not_Q1);   // ~Q2 & ~Q1
and u13(term3b, Q0, input_sequence); // Q0 & in
and u14(term3,  term3a, term3b);    // ~Q2&~Q1&Q0&in（第一项）
and u15(term4a, not_Q2, Q1);        // ~Q2 & Q1
and u16(term4b, not_Q0, input_sequence); // ~Q0 & in
and u17(term4,  term4a, term4b);    // ~Q2&Q1&~Q0&in（第二项）
or  u18(Q1_next, term3, term4);    // 两项或操作得到Q1_next

// 4. 实现Q0_next逻辑：Q0_next = (~Q2·~Q0·in) ∨ (Q2·~Q1·in)
and u19(term5a, not_Q2, not_Q0);   // ~Q2 & ~Q0
and u20(term5,  term5a, input_sequence); // ~Q2&~Q0&in（第一项）
and u21(term6a, Q2, not_Q1);        // Q2 & ~Q1（复用Q2_next的term2a）
and u22(term6,  term6a, input_sequence); // Q2&~Q1&in（第二项，复用Q2_next的term2）
or  u23(Q0_next, term5, term6);    // 两项或操作得到Q0_next

// 5. 实例化3个D触发器（异步高有效复位）
// DFF原语：d(数据端), clk(时钟), rst(复位), q(输出)
dff u24(
    .d(Q2_next),
    .clk(clk),
    .rst(not_rst_n),
    .q(Q2)
);
dff u25(
    .d(Q1_next),
    .clk(clk),
    .rst(not_rst_n),
    .q(Q1)
);
dff u26(
    .d(Q0_next),
    .clk(clk),
    .rst(not_rst_n),
    .q(Q0)
);

// 6. 实现detected逻辑：detected = Q2·~Q1·in
and u27(term7a, Q2, not_Q1);       // Q2 & ~Q1
and u28(detected, term7a, input_sequence); // 最终输出

endmodule

// 注：需提前定义DFF原语（异步高有效复位）
module dff(
    input  logic d,
    input  logic clk,
    input  logic rst,
    output logic q
);
always_ff @(posedge clk or posedge rst) begin
    if (rst) begin
        q <= 1'b0;
    end else begin
        q <= d;
    end
end
endmodule
```


## 5. 行为级SystemVerilog建模（状态机描述）
行为级用**枚举类型**定义状态，用`always_ff`（时序）和`always_comb`（组合）块描述状态转移和输出，更直观易维护。

```systemverilog
module sequence_detector_behavioral(
    input  logic clk,          // 时钟
    input  logic rst_n,        // 异步低有效复位
    input  logic input_sequence, // 输入序列
    output logic detected      // 检测输出
);

// 1. 定义状态枚举类型（对应3位编码）
typedef enum logic [2:0] {
    S0 = 3'b000,  // 0个连续1
    S1 = 3'b001,  // 1个连续1
    S2 = 3'b010,  // 2个连续1
    S3 = 3'b011,  // 3个连续1
    S4 = 3'b100,  // 4个连续1
    S5 = 3'b101   // 5个及以上连续1
} state_t;

// 2. 声明当前状态和次态
state_t current_state;
state_t next_state;

// 3. 时序逻辑：同步更新当前状态（异步复位）
always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        current_state <= S0; // 复位到初始状态S0
    end else begin
        current_state <= next_state; // 时钟上升沿更新次态
    end
end

// 4. 组合逻辑：计算次态（避免 latch，默认保持当前状态）
always_comb begin
    next_state = current_state; // 默认不变
    case (current_state)
        S0: begin
            if (input_sequence == 1'b1) begin
                next_state = S1;
            end
        end
        S1: begin
            if (input_sequence == 1'b1) begin
                next_state = S2;
            end else begin
                next_state = S0;
            end
        end
        S2: begin
            if (input_sequence == 1'b1) begin
                next_state = S3;
            end else begin
                next_state = S0;
            end
        end
        S3: begin
            if (input_sequence == 1'b1) begin
                next_state = S4;
            end else begin
                next_state = S0;
            end
        end
        S4: begin
            if (input_sequence == 1'b1) begin
                next_state = S5;
            end else begin
                next_state = S0;
            end
        end
        S5: begin
            if (input_sequence == 1'b0) begin
                next_state = S0;
            end
        end
        default: next_state = S0; // 异常状态复位到S0
    endcase
end

// 5. 组合逻辑：计算输出detected
assign detected = (current_state == S4 && input_sequence == 1'b1) || 
                  (current_state == S5 && input_sequence == 1'b1);

endmodule
```


## 6. 验证与结果比较（Testbench）
通过Testbench生成激励，同时实例化结构化和行为级模块，比较输出一致性并观察波形。


### 6.1 Testbench代码
```systemverilog
module tb_sequence_detector;

// 1. 声明内部信号
logic clk;                  // 时钟
logic rst_n;                // 复位
logic input_sequence;       // 输入激励
logic detected_struct;      // 结构化模块输出
logic detected_behavior;    // 行为级模块输出

// 2. 实例化待测试模块
sequence_detector_structural u_struct(
    .clk(clk),
    .rst_n(rst_n),
    .input_sequence(input_sequence),
    .detected(detected_struct)
);

sequence_detector_behavioral u_behavior(
    .clk(clk),
    .rst_n(rst_n),
    .input_sequence(input_sequence),
    .detected(detected_behavior)
);

// 3. 生成时钟（50MHz，周期20ns）
initial begin
    clk = 1'b0;
    forever #10 clk = ~clk; // 10ns高，10ns低
end

// 4. 生成复位信号（初始复位，25ns后释放）
initial begin
    rst_n = 1'b0;
    #25 rst_n = 1'b1; // 过1.5个时钟周期释放，确保稳定
    #1000 $finish;    // 仿真1000ns后结束
end

// 5. 生成输入激励（覆盖关键场景）
initial begin
    input_sequence = 1'b0;
    #30; // 复位释放后开始激励

    // 场景1：少于5个1（0→1→1→1→0）
    input_sequence = 1'b0; #20;
    input_sequence = 1'b1; #20;
    input_sequence = 1'b1; #20;
    input_sequence = 1'b1; #20;
    input_sequence = 1'b0; #20;

    // 场景2：正好5个1（0→1×5→0）
    input_sequence = 1'b0; #20;
    input_sequence = 1'b1; #20; // 1
    input_sequence = 1'b1; #20; // 2
    input_sequence = 1'b1; #20; // 3
    input_sequence = 1'b1; #20; // 4
    input_sequence = 1'b1; #20; // 5（detected=1）
    input_sequence = 1'b0; #20; // 0（detected=0）

    // 场景3：多于5个1（1×7）
    input_sequence = 1'b1; #20; // 1
    input_sequence = 1'b1; #20; // 2
    input_sequence = 1'b1; #20; // 3
    input_sequence = 1'b1; #20; // 4
    input_sequence = 1'b1; #20; // 5（1）
    input_sequence = 1'b1; #20; // 6（1）
    input_sequence = 1'b1; #20; // 7（1）

    // 场景4：中间有0打断（1×3→0→1×5）
    input_sequence = 1'b1; #20; // 1
    input_sequence = 1'b1; #20; // 2
    input_sequence = 1'b1; #20; // 3
    input_sequence = 1'b0; #20; // 0（回到S0）
    input_sequence = 1'b1; #20; // 1
    input_sequence = 1'b1; #20; // 2
    input_sequence = 1'b1; #20; // 3
    input_sequence = 1'b1; #20; // 4
    input_sequence = 1'b1; #20; // 5（1）

    // 场景5：全0
    input_sequence = 1'b0; #100;
end

// 6. 监测输出一致性（断言报错）
always @(posedge clk) begin
    if (rst_n) begin
        assert (detected_struct == detected_behavior) else begin
            $error("[%0t ns] 输出不匹配：结构化=%b，行为级=%b", 
                   $time, detected_struct, detected_behavior);
        end
    end
end

// 7. 打印信号（可选）
initial begin
    $monitor("[%0t ns] clk=%b, rst_n=%b, in=%b, struct_out=%b, behavior_out=%b",
             $time, clk, rst_n, input_sequence, detected_struct, detected_behavior);
end

endmodule
```


### 6.2 仿真结果预期
1. **输出一致性**：  
   复位释放后，`detected_struct`与`detected_behavior`在所有时钟周期完全一致，无断言报错。

2. **关键场景验证**：  
   - 场景2（5个1）：第5个1输入时，`detected`变高，下一个周期输入0时变低；  
   - 场景3（7个1）：第5~7个1输入时，`detected`保持高；  
   - 场景4（中间有0）：前3个1后输入0，`detected`不变低，后续5个1时`detected`变高。

3. **波形观察**：  
   在ModelSim等工具中添加波形（`clk, rst_n, input_sequence, detected_struct, detected_behavior`），可见：  
   - 时钟为周期性方波；  
   - 复位期间输出全0；  
   - 两个模块的`detected`波形完全重叠，证明设计正确。


## 总结
- 本设计采用Mealy型FSM，通过6个状态实现5连1序列检测，满足“第5个1断言+持续1保持断言”的需求；  
- 结构化建模（门级）严格遵循布尔表达式，行为级建模（状态机）更易维护，两者功能完全一致；  
- Testbench覆盖所有关键场景，验证结果证明设计正确。